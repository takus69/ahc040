# AHC040

## 日記

### 20241130

- 至高のアルゴリズムに参加していて初日は考察できず。二日目からスタート！
- グッズを順に箱に詰めて、そのサイズの最小化が目的
- 入れないグッズがあってもよいが、それは個別でサイズが計算される。変な隙間ができて、他の箱の邪魔にしかならない特殊なケース以外は、箱に入れる方がよいと考えられる。そのため入れないパターンは考えなくてもよいかも？ => 1個だけポツンと1行全て隙間ができるパターンを考える。その場合でも外に出すとhiが加算されるスコアになるので、すべて入れた方がスコアは良くなるはず。つまり邪魔なら一番邪魔にならない端っこ辺りにおけばいい？
- グッズのサイズ、入れ終わった箱のサイズは目分量しかないため、グッズのサイズを推測しながら最適な入れ方を探す
- 目分量のため報告の箱のサイズが大きくても実はスコアはいいというのがあり得る
- グッズのサイズが明確になっていると最適解が求められるのか？ => 多分ノー
  - 自由度は、箱の数(N)、入れるか入れないか(2)、回転するかしないか(2)、上左どちらに合わせるか(2)、どの箱に合わせるか(それまでに入れた数。最大Nで合計N*(N+1)/2) = 4*N^2*(N+1)かな？ => 上記で全部入れた方が良いとなれば自由度が下がり、全探索する回数は、2*N^2*(n+1) => 違った。8^N以上かかる。。。
  - Nは30～100だから、O(N^3)だと最大10^6 => サイズがわかっていれば、全探索できる？ => 上記のためできない
- 誤差を関係なく、全探索で最適解と思われるものを提出する？誤差が積みあがるので、結構な差が出ると思うが、初期解としてはいいかも
- 推測はベイズの定理を使うのかな。研究として最尤推定との違いも見てみたい
- TがN/2～4N = 15～400だから、すべて全探索していると時間が足りない。ランダムで提出してグッズのサイズを推測して、それをもとに最適解を提出という感じ？

- 全探索しようと思ったらスコア計算難しくない？？？
  - 正確なグッズのサイズがわかればスコア計算もできるが、ちょいずれで思ったように置けてなければ、かなりスコアの推測値が違ってくることになる
    - 各グッズを入れたら、その座標は分かる
    - 合わせるグッズを決めると、xやyは決まる。もう片方が他の箱も含めて最大の位置になる。各頂点に関する最大値をもっておく、そして自分の範囲内の最大値を探索すれば、置ける最大値がわかる(セグ木？)
- 最適解求めようとしても目分量だから、少し小さめになっていたら、目分量で合わせたら大きくずれるってことがあるのか。。。ちょいずれでひっかかって縦横に空間できるような置き方になりそう。それは箱に入れないのと同じぐらいのスコアになってしまうが、重なった部分が少し効率的になるので入れないよりはましになるはず => サイズ指定して入れるのではなく、どのグッズに合わせて入れてみてという形なので、少しずれて入らないというのは、あまりない。ただ他のグッズの位置が少しずれるので、邪魔にならないと思っていたのに邪魔でちゃんと入らなかったというのはありそう

- 全探索可能と勘違いしていたので、考え直し。。。
- とりあえず決めたときに、スコア計算(推測)ができるようにする。ベイズ推定と入れ方の最適化を考えるか

- occupancyは充填率。箱の面積に対して、グッズの面積の和の率。無駄がどの程度あるかがわかるが、この値が100%に近くても箱の縦横の使い方が良くなければスコアは悪くなる

- 縦に並べるだけの実装 => 正方形になるように並べる
  - 縦に並べる時に下から上じゃなく、右から左に置くと途中にひっかかることがなく、縦に順番通りに接する形で置けるので、無駄が少なくなる
- 実際の値に合わせたスコア計算ができてないため、実装が必要
- 改善のネタは以下
  - 回転などで変更して貪欲
  - ビームサーチ

### 20241201

- 貪欲に改善しようと思ったけど、途中の評価が難しい
  - w+hを貪欲にすると、新しい列を作るより下に置いて行った方がwが重なる分よくなる
  - すでに新しい列がある場合はどっちに置いた方が良いかという話にはなる
  - その際は、一番新しい列ははみ出るリスクがある
  - 古い列は下に新しく伸びる場合は良くない
- 置く順番と位置は同じで、回転するかどうかだけで貪欲を考える
  - 現状のw+hが良くなる方を採用すると、新しく下に伸ばすより、横にしてはみ出しを多くした方がw+hが良くなるが、でっぱりが多くよくない
  - 現時点の充填率を見て、良い方を採用するといいのでは？ => 既に配置したグッズの面積の和 / w*h が良くなる置き方にする => 無駄の少ない置き方になる
- 上記を試してみてあまり変わらなかった。スコア計算がちゃんとできてないので、そっちを先にする

### 20241202

- 昨日はほとんどできなかった。。。
- まずはジャッジが返してくれるスコア、実際のスコアを計算できるようにした
- 全体の充填率を見て追加ははみ出さないのが良くなるので、列ごとの充填率がいい方を採用した方がよさそう

### 20241206

- インフルで倒れていてようやく復活！
- 列ごとの充足率を実装。yは足しているだけだけど、xは最大をとっている
- x方向は凹んだところに入るとmax_xが小さくなるので、はまったと認識してそうなところがある
- 誤差の関係で少しずれてはまっていない。。。 => 実際の目分量の大きさを見ると、そうでもない。。。
- 閾値ちょい越えで、箱を大きくしているのもある
- 回転の自由度だけから、どの後ろに配置するかの自由度を追加して、ビームサーチを実装したい
- 全体の目分量の結果を使いたい
- ビームサーチの実装
  - Boxの初期化
  - 以下の処理を繰り返す
    - Boxをコピー
    - ランダムな操作を選択して配置(回転、どの列に配置するかの自由度)(何個の操作を試すか決める)
    - その後の操作は貪欲(回転の自由度の検証はして、後ろに順に追加していく)(プレイアウト)
    - スコアの小さい順にビーム幅を最大数として保持(優先度付きキュー、Boxとスコアを保持)
- 全体の目分量の結果利用

### 20241207

- ビームサーチを実装しようとしたけれども、箱にグッズを追加する際の挙動が制限付きすぎていてうまくいかなそうなので、箱にグッズを追加する際の実装を見直すことを先にする

### 20241208

- 箱にグッズを追加する仕様を整理
  - dは'L'のみに固定で、縦に並べていき、縦に何列にも並べる
    - こうすることで引っかかって、所定のy座標に到達しない状況はなくなる
    - ただしx座標がずれて、縦に並んでいるとは思えない状況にはなる(要データ確認、改善)
  - 回転rと、何列目に追加するか(bが決まる)で、追加する
    - 追加可能な列を情報として保持する
    - 後の列の方が長くなる対処が必要 => 次の列の長さが超えたら、その列はクローズする？
    - 前の列が凹んでいた時の対処(もう少し詰めてもいい)が必要 => max_xが少ないと再追加する？(bを変えない)
- 何とかビームサーチを実装してみて、少し良くなったけど、提出するとそれほどでもない
- 同じビームが繰り返されているので、そこ改善しないと！ => ハッシュ関数で同一性を確認して、改善

### 20241209

- ローカルのデバッグモードでは遅いけど、提出したらもっと早いので、ビーム幅などを広げてる。ローカルではテストできないけど、得点上昇中
  - v4: ビーム幅2倍, 試行回数2倍, ハッシュ関数で同一性確認(58ms)
  - v5: ビーム幅4倍, 試行回数4倍(54ms)
  - v6: ビーム幅16倍orTの小さい方, 試行回数4倍(180ms, 278位)
  - v7: ビーム幅32倍orTの小さい方, 試行回数16倍(518ms, 328位) => ビーム幅, 試行回数を増やして減ることがあるのか。。。 => 乱数がうまいのをとらなかった？
  - v8: ビーム幅T, 試行回数16倍(3022ms, 1件TLE, 410位) => TLE1件あると、2%点数が減少するのでかなり大きい。システムテストだと影響は軽微だが。。。試行回数が多いと同じ結果が残り多様性が確保されない？
  - v9: ビーム幅T, 試行回数8倍(2477ms, 278位)
  - v10: ビーム幅T, 試行回数4倍(2144ms, 238位)
  - v11: ビーム幅T, 試行回数4倍, 一つ前の列のmax_xより小さい場合(前の列にはまった)は列の最後のグッズを更新しない => ハマった場合にかなり改善するが、少しずれてハマってなかった時が悲惨。そしてハマったものが良すぎて、他の状態のが残ってなかった。。。

## クラス設計

- Boxクラス
  - goodses: [(w, h)]
  - goods_statuses: [(x1, y1, x2, y2)]
  - score: int
  - instructions: [(r, d, b)]
  - add(goods, status)

## history

- v0: 縦に並べる(提出: 218,618,671)
- v1: 正方形になるように縦に並べる(提出: 62,175,618)
- v2: 列ごとの充足率で回転の自由度を追加(予測: 58,991,553, 提出: 60,452,811)
- v3: ビームサーチ実装(予測: 56,131,606, 提出: 60,013,729)
- v4: ビーム幅2倍, 試行回数2倍, ハッシュ関数で同一性確認(N=30でビーム幅/試行回数10回, N=100でビーム幅/試行回数3回)(予測: 54,841,350, 提出: 58,981,268)
- v5: ビーム幅4倍, 試行回数4倍(予測: 54,331,134, 提出: 58,804,095)
- v6: ビーム幅16倍orTの小さい方, 試行回数4倍(予測: ローカルでは処理終わらず, 提出: 58,283,713)
- v7: ビーム幅32倍orTの小さい方, 試行回数16倍(予測: x, 提出: 58,767,688)
- v8: ビーム幅T, 試行回数16倍(1件TLE)
- v9: ビーム幅T, 試行回数8倍(提出: 58,280,521)
- v10: ビーム幅T, 試行回数4倍(提出: 57,965,374)

## 実行コマンド

- 1テストケース実行

```
cargo build
cat .\in\0000.txt | .\target\debug\ahc040.exe > .\out\0000.txt
```

- 一括実行

```
cargo build
python .\simulator.py
